<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Résolution de Labyrinthe par Algorithme Génétique</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Warm Neutrals -->
    <!-- Application Structure Plan: A single-page application designed as an interactive sandbox. The primary section features a canvas for maze visualization and controls for generation and solving, allowing for immediate hands-on experience. This is followed by collapsible sections explaining the core concepts (Maze Generation, Genetic Algorithm, Architecture) in a digestible format, preventing information overload. A final section displays a dynamic chart for performance analysis. This structure prioritizes user engagement and learning by doing, rather than a linear text-based presentation, making the complex topic more accessible and intuitive. -->
    <!-- Visualization & Content Choices: 
        - Maze Visualization -> Goal: Inform/Interact -> Method: HTML Canvas -> Interaction: Dynamic drawing of maze and animated solution path -> Justification: Canvas provides the necessary low-level drawing capabilities for a grid-based visualization and smooth animation.
        - GA Performance -> Goal: Show Change/Trend -> Method: Chart.js Line Chart -> Interaction: Chart is populated post-simulation; tooltips on hover -> Justification: A line chart is the standard and most effective way to show performance improvement (fitness) over time (generations).
        - Core Concepts (DFS, GA Principles) -> Goal: Organize/Inform -> Method: Interactive HTML/CSS accordions with flexbox layouts for diagrams -> Interaction: User clicks to expand/collapse sections -> Justification: Breaks down complex information into manageable chunks, improving readability and user control over information flow.
        - Architecture Diagram -> Goal: Organize -> Method: Styled HTML divs with Tailwind CSS (Flexbox) -> Interaction: Static visual -> Justification: A simple, clean diagram built with HTML/CSS is sufficient to convey the client-server relationship without external libraries or complex graphics.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #FDFBF8;
            color: #4A4A4A;
        }
        .control-panel-bg { background-color: #FFFFFF; }
        .btn-primary { background-color: #A88B79; color: #FFFFFF; }
        .btn-primary:hover { background-color: #8E7361; }
        .btn-secondary { background-color: #EFEBE8; color: #6B6B6B; }
        .btn-secondary:hover { background-color: #DCD6D1; }
        .accent-color { color: #A88B79; }
        .border-color { border-color: #DCD6D1; }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 400px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 400px;
            }
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #A88B79;
            cursor: pointer;
            border-radius: 50%;
        }
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #A88B79;
            cursor: pointer;
            border-radius: 50%;
        }
        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .accordion-button.open + .accordion-content {
            max-height: 1000px;
        }
    </style>
</head>
<body class="antialiased">

    <div class="container mx-auto p-4 md:p-8">
        
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-4xl font-bold accent-color mb-2">Projet : Résolution de Labyrinthe</h1>
            <p class="text-lg text-gray-600">Une exploration interactive des algorithmes génétiques</p>
        </header>

        <main>
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                
                <div class="lg:col-span-2 order-2 lg:order-1">
                    <div class="bg-white p-4 rounded-lg shadow-md border border-color">
                        <canvas id="mazeCanvas" class="w-full h-auto aspect-square rounded"></canvas>
                    </div>
                     <div id="status-message" class="text-center mt-4 font-medium text-gray-700 h-6"></div>
                </div>

                <div class="order-1 lg:order-2">
                    <div class="control-panel-bg p-6 rounded-lg shadow-md border border-color sticky top-8">
                        <h2 class="text-xl font-bold mb-4 text-gray-800">Panneau de Contrôle</h2>
                        
                        <div class="space-y-6">
                            <div>
                                <label for="mazeSize" class="block text-sm font-medium text-gray-700">Taille du Labyrinthe: <span id="mazeSizeValue" class="font-bold accent-color">21x21</span></label>
                                <input id="mazeSize" type="range" min="11" max="51" step="2" value="21" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider">
                            </div>

                            <div class="border-t border-color pt-4 mt-4">
                                <label for="opennessRate" class="block text-sm font-medium text-gray-700">Ouverture du Labyrinthe: <span id="opennessRateValue" class="font-bold accent-color">0%</span></label>
                                <input id="opennessRate" type="range" min="0" max="100" step="5" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider">
                                <p class="text-xs text-gray-500 mt-1">Plus la valeur est élevée, plus le labyrinthe aura de boucles et de chemins.</p>
                            </div>

                            <div class="border-t border-color pt-4 mt-4">
                                <label for="seedInput" class="block text-sm font-medium text-gray-700">Graine de Génération (Seed):</label>
                                <div class="flex items-center space-x-2">
                                    <input type="text" id="seedInput" value="" placeholder="Laissez vide pour aléatoire" class="flex-1 p-2 border border-gray-300 rounded-lg focus:ring-accent-color focus:border-accent-color">
                                    <button id="randomSeedBtn" class="btn-secondary px-3 py-2 text-sm rounded-lg transition-colors duration-200">Graine Aléatoire</button>
                                </div>
                                <p class="text-xs text-gray-500 mt-1">Utilisez une graine spécifique pour générer le même labyrinthe de manière reproductible.</p>
                            </div>

                            <button id="generateBtn" class="w-full btn-secondary font-bold py-2 px-4 rounded-lg transition-colors duration-200">Générer un Labyrinthe</button>
                            
                            <hr class="border-color">

                            <div>
                                <label for="populationSize" class="block text-sm font-medium text-gray-700">Taille Population: <span id="populationSizeValue" class="font-bold accent-color">100</span></label>
                                <input id="populationSize" type="range" min="50" max="500" step="10" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider">
                            </div>

                            <div>
                                <label for="generations" class="block text-sm font-medium text-gray-700">Générations: <span id="generationsValue" class="font-bold accent-color">50</span></label>
                                <input id="generations" type="range" min="10" max="200" step="5" value="50" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider">
                            </div>

                            <div>
                                <label for="mutationRate" class="block text-sm font-medium text-gray-700">Taux de Mutation: <span id="mutationRateValue" class="font-bold accent-color">5%</span></label>
                                <input id="mutationRate" type="range" min="1" max="20" step="1" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider">
                            </div>

                            <button id="solveBtn" class="w-full btn-primary font-bold py-3 px-4 rounded-lg transition-colors duration-200 text-lg">Résoudre</button>
                        </div>
                    </div>
                </div>
            </div>

            <section id="results-section" class="mt-12 p-6 bg-white rounded-lg shadow-md border border-color hidden">
                <h2 class="text-2xl font-bold text-center mb-4 text-gray-800">Performance de l'Algorithme</h2>
                <p class="text-center text-gray-600 mb-6">Ce graphique illustre l'amélioration de la meilleure "fitness" (aptitude) de la population à chaque génération. Une courbe ascendante rapide indique une convergence efficace vers une bonne solution.</p>
                <div class="chart-container">
                    <canvas id="fitnessChart"></canvas>
                </div>
            </section>

            <section class="mt-12">
                <h2 class="text-2xl font-bold text-center mb-6 text-gray-800">Comment Ça Marche ?</h2>
                <div class="space-y-4 max-w-4xl mx-auto">
                    <div class="border border-color rounded-lg bg-white">
                        <button class="accordion-button w-full text-left p-4 font-semibold text-lg flex justify-between items-center transition-colors hover:bg-gray-50">
                            <span>1. Génération du Labyrinthe (DFS)</span>
                            <span class="transform transition-transform duration-300">▼</span>
                        </button>
                        <div class="accordion-content">
                            <div class="p-4 border-t border-color text-gray-700">
                                <p class="mb-4">Le labyrinthe est créé à l'aide de l'algorithme de **Parcours en Profondeur (Depth-First Search)**. Cette méthode "creuse" des chemins à travers une grille pleine de murs, garantissant qu'il existe toujours un chemin unique entre le départ et l'arrivée.</p>
                                <div class="flex flex-col sm:flex-row gap-4 text-center">
                                    <div class="flex-1 p-3 bg-gray-100 rounded">1. Grille pleine de murs</div>
                                    <div class="self-center text-2xl accent-color">→</div>
                                    <div class="flex-1 p-3 bg-gray-100 rounded">2. Choisir un point, explorer et marquer</div>
                                    <div class="self-center text-2xl accent-color">→</div>
                                    <div class="flex-1 p-3 bg-gray-100 rounded">3. Revenir sur ses pas si bloqué</div>
                                    <div class="self-center text-2xl accent-color">→</div>
                                    <div class="flex-1 p-3 bg-gray-100 rounded">4. Répéter jusqu'à tout visiter</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="border border-color rounded-lg bg-white">
                        <button class="accordion-button w-full text-left p-4 font-semibold text-lg flex justify-between items-center transition-colors hover:bg-gray-50">
                            <span>2. L'Algorithme Génétique</span>
                            <span class="transform transition-transform duration-300">▼</span>
                        </button>
                        <div class="accordion-content">
                             <div class="p-4 border-t border-color text-gray-700 space-y-4">
                                <p>L'algorithme génétique imite la sélection naturelle pour trouver le chemin optimal. Il fait évoluer une population de solutions (chemins) sur plusieurs générations.</p>
                                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 text-center">
                                    <div class="p-3 bg-gray-100 rounded"><strong>Population</strong><p class="text-sm">Ensemble de chemins aléatoires.</p></div>
                                    <div class="p-3 bg-gray-100 rounded"><strong>Fitness</strong><p class="text-sm">Note évaluant chaque chemin (proximité de la sortie, pénalités pour les murs).</p></div>
                                    <div class="p-3 bg-gray-100 rounded"><strong>Sélection</strong><p class="text-sm">Les meilleurs chemins sont choisis pour se "reproduire".</p></div>
                                    <div class="p-3 bg-gray-100 rounded"><strong>Croisement</strong><p class="text-sm">Deux chemins parents échangent des parties pour créer des enfants.</p></div>
                                    <div class="p-3 bg-gray-100 rounded"><strong>Mutation</strong><p class="text-sm">De petits changements aléatoires sont introduits pour la diversité.</p></div>
                                </div>
                            </div>
                        </div>
                    </div>
                     <div class="border border-color rounded-lg bg-white">
                        <button class="accordion-button w-full text-left p-4 font-semibold text-lg flex justify-between items-center transition-colors hover:bg-gray-50">
                            <span>3. Architecture de l'Application</span>
                            <span class="transform transition-transform duration-300">▼</span>
                        </button>
                        <div class="accordion-content">
                            <div class="p-4 border-t border-color text-gray-700">
                                <p class="mb-4">Ce projet est conçu comme une application web interactive. Dans une version complète, un backend Python gérerait la logique complexe, tandis que le frontend (ce que vous voyez) s'occuperait de la visualisation. Pour cette démonstration, toute la logique est simulée en JavaScript dans votre navigateur.</p>
                                <div class="flex flex-col sm:flex-row items-center justify-center gap-4 text-center font-medium">
                                    <div class="p-4 bg-blue-100 text-blue-800 rounded-lg w-48">Frontend (HTML/JS)<br><span class="text-sm font-normal">Interface & Visualisation</span></div>
                                    <div class="flex flex-col items-center">
                                        <span class="text-sm">Requête API (JSON)</span>
                                        <span class="text-2xl accent-color">⇄</span>
                                        <span class="text-sm">Réponse (JSON)</span>
                                    </div>
                                    <div class="p-4 bg-green-100 text-green-800 rounded-lg w-48">Backend (Python/Flask)<br><span class="text-sm font-normal">Génération & Algorithme</span></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('mazeCanvas');
    const ctx = canvas.getContext('2d');

    const mazeSizeSlider = document.getElementById('mazeSize');
    const mazeSizeValue = document.getElementById('mazeSizeValue');
    const opennessRateSlider = document.getElementById('opennessRate'); // New
    const opennessRateValue = document.getElementById('opennessRateValue'); // New
    const seedInput = document.getElementById('seedInput'); // New
    const randomSeedBtn = document.getElementById('randomSeedBtn'); // New

    const populationSizeSlider = document.getElementById('populationSize');
    const populationSizeValue = document.getElementById('populationSizeValue');
    const generationsSlider = document.getElementById('generations');
    const generationsValue = document.getElementById('generationsValue');
    const mutationRateSlider = document.getElementById('mutationRate');
    const mutationRateValue = document.getElementById('mutationRateValue');
    
    const generateBtn = document.getElementById('generateBtn');
    const solveBtn = document.getElementById('solveBtn');
    const statusMessage = document.getElementById('status-message');
    const resultsSection = document.getElementById('results-section');

    const WALL = 1;
    const PATH = 0;

    let maze, start, end, size;
    let cellSize;
    let isSolving = false;

    let fitnessChart;

    // Simple Linear Congruential Generator (LCG) for seeded random numbers
    let currentSeed = Date.now(); // Default seed, updated by input or button

    function setSeed(seed) {
        currentSeed = seed;
    }

    function seededRandom() {
        currentSeed = (currentSeed * 9301 + 49297) % 233280;
        return currentSeed / 233280;
    }

    const updateSliderValue = (slider, display, formatter) => {
        display.textContent = formatter(slider.value);
        slider.addEventListener('input', (e) => {
            display.textContent = formatter(e.target.value);
        });
    };

    updateSliderValue(mazeSizeSlider, mazeSizeValue, v => `${v}x${v}`);
    updateSliderValue(opennessRateSlider, opennessRateValue, v => `${v}%`); // New slider
    updateSliderValue(populationSizeSlider, populationSizeValue, v => v);
    updateSliderValue(generationsSlider, generationsValue, v => v);
    updateSliderValue(mutationRateSlider, mutationRateValue, v => `${v}%`);

    randomSeedBtn.addEventListener('click', () => {
        const newSeed = Math.floor(Math.random() * 1000000000);
        seedInput.value = newSeed;
        setSeed(newSeed);
    });

    seedInput.addEventListener('input', () => {
        const seedVal = parseInt(seedInput.value);
        if (!isNaN(seedVal)) {
            setSeed(seedVal);
        } else {
            // If input is cleared or invalid, revert to a default random behavior for new maze
            setSeed(Date.now()); 
        }
    });

    function generateMaze(width, height, opennessPercent, currentMazeSeed) {
        setSeed(currentMazeSeed); // Set the seed for this generation

        let mazeGrid = Array(height).fill(null).map(() => Array(width).fill(WALL));
        let stack = [];
        let startX = 1, startY = 1;

        mazeGrid[startY][startX] = PATH;
        stack.push([startX, startY]);

        while (stack.length > 0) {
            let [x, y] = stack[stack.length - 1];
            let neighbors = [];

            [[x, y - 2], [x, y + 2], [x - 2, y], [x + 2, y]].forEach(([nx, ny]) => {
                if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1 && mazeGrid[ny][nx] === WALL) {
                    neighbors.push([nx, ny]);
                }
            });

            if (neighbors.length > 0) {
                // Use seededRandom for maze generation decisions
                let [nextX, nextY] = neighbors[Math.floor(seededRandom() * neighbors.length)];
                mazeGrid[nextY][nextX] = PATH;
                mazeGrid[y + (nextY - y) / 2][x + (nextX - x) / 2] = PATH;
                stack.push([nextX, nextY]);
            } else {
                stack.pop();
            }
        }
        
        start = { x: 1, y: 1 };
        end = { x: width - 2, y: height - 2 };
        mazeGrid[start.y][start.x] = PATH;
        mazeGrid[end.y][end.x] = PATH;
        
        // Ensure path to start/end exists if they are isolated by initial generation
        if (mazeGrid[height - 3][width - 2] === WALL) mazeGrid[height - 3][width - 2] = PATH;
        if (mazeGrid[height - 2][width - 3] === WALL) mazeGrid[height - 2][width - 3] = PATH;

        // Introduce openness: convert some walls to paths after initial generation
        const opennessThreshold = opennessPercent / 100;
        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                if (mazeGrid[y][x] === WALL) {
                    // Check neighbors to ensure we don't create isolated path segments
                    let pathNeighbors = 0;
                    if (y > 0 && mazeGrid[y-1][x] === PATH) pathNeighbors++;
                    if (y < height-1 && mazeGrid[y+1][x] === PATH) pathNeighbors++;
                    if (x > 0 && mazeGrid[y][x-1] === PATH) pathNeighbors++;
                    if (x < width-1 && mazeGrid[y][x+1] === PATH) pathNeighbors++;

                    // Only convert wall to path if it has at least one path neighbor and random check passes
                    if (pathNeighbors > 0 && seededRandom() < opennessThreshold) {
                        mazeGrid[y][x] = PATH;
                    }
                }
            }
        }

        return mazeGrid;
    }

    function drawMaze() {
        if (!maze) return;
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        cellSize = canvas.width / size;

        for (let y = 0; y < size; y++) {
            for (let x = 0; x < size; x++) {
                ctx.fillStyle = maze[y][x] === WALL ? '#4A4A4A' : '#FFFFFF';
                ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
            }
        }

        ctx.fillStyle = '#4CAF50';
        ctx.fillRect(start.x * cellSize, start.y * cellSize, cellSize, cellSize);
        
        ctx.fillStyle = '#F44336';
        ctx.fillRect(end.x * cellSize, end.y * cellSize, cellSize, cellSize);
    }

    function drawPath(path, color = 'rgba(168, 139, 121, 0.7)') {
        if (!path || path.length === 0) return;
        ctx.lineWidth = cellSize * 0.4;
        ctx.strokeStyle = color;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        ctx.beginPath();
        ctx.moveTo((path[0].x + 0.5) * cellSize, (path[0].y + 0.5) * cellSize);
        for (let i = 1; i < path.length; i++) {
            ctx.lineTo((path[i].x + 0.5) * cellSize, (path[i].y + 0.5) * cellSize);
        }
        ctx.stroke();
    }

    function initNewMaze() {
        size = parseInt(mazeSizeSlider.value);
        const openness = parseInt(opennessRateSlider.value);
        let currentMazeSeed = parseInt(seedInput.value);
        if (isNaN(currentMazeSeed)) {
            currentMazeSeed = Date.now();
            seedInput.value = currentMazeSeed; // Update input with actual random seed used
        }
        setSeed(currentMazeSeed); // Ensure the LCG is set for this generation

        maze = generateMaze(size, size, openness, currentMazeSeed);
        drawMaze();
        statusMessage.textContent = "Nouveau labyrinthe généré. Prêt à résoudre.";
        resultsSection.classList.add('hidden');
    }

    generateBtn.addEventListener('click', initNewMaze);

    solveBtn.addEventListener('click', async () => {
        if (!maze) {
            alert("Veuillez d'abord générer un labyrinthe.");
            return;
        }
        if (isSolving) return;

        isSolving = true;
        solveBtn.disabled = true;
        generateBtn.disabled = true;
        solveBtn.textContent = "Résolution en cours...";
        solveBtn.classList.replace('btn-primary', 'btn-secondary');
        statusMessage.textContent = "Initialisation de l'algorithme...";
        
        await new Promise(resolve => setTimeout(resolve, 100));

        const populationSize = parseInt(populationSizeSlider.value);
        const numGenerations = parseInt(generationsSlider.value);
        const mutationRate = parseInt(mutationRateSlider.value) / 100;
        // La longueur du chemin a été considérablement augmentée pour permettre une exploration plus profonde.
        const pathLength = size * size * 2; 

        let population = [];
        const fitnessHistory = [];

        function createIndividual() {
            const moves = ['N', 'E', 'S', 'W'];
            let chromosome = [];
            for (let i = 0; i < pathLength; i++) {
                chromosome.push(moves[Math.floor(Math.random() * 4)]); // Use Math.random for GA, not seededRandom
            }
            return { chromosome: chromosome, fitness: 0 };
        }

        for (let i = 0; i < populationSize; i++) {
            population.push(createIndividual());
        }

        function calculateFitness(individual) {
            let pos = { ...start };
            let path = [{...start}];
            let score = 0;
            let visited = new Set([`${start.x},${start.y}`]);

            for (const move of individual.chromosome) {
                let nextPos = { ...pos };
                if (move === 'N') nextPos.y--;
                else if (move === 'E') nextPos.x++;
                else if (move === 'S') nextPos.y++;
                else if (move === 'W') nextPos.x--;

                if (nextPos.x < 0 || nextPos.x >= size || nextPos.y < 0 || nextPos.y >= size || maze[nextPos.y][nextPos.x] === WALL) {
                    score -= 10;
                } else {
                    pos = nextPos;
                    path.push({...pos});
                    if (!visited.has(`${pos.x},${pos.y}`)) {
                        score += 2;
                        visited.add(`${pos.x},${pos.y}`);
                    } else {
                        score -= 1;
                    }
                }
                
                if (pos.x === end.x && pos.y === end.y) {
                    score += 10000 - path.length * 5;
                    break;
                }
            }
            
            const distToEnd = Math.abs(pos.x - end.x) + Math.abs(pos.y - end.y);
            score -= distToEnd * 5;
            
            individual.fitness = score;
            return path;
        }

        function tournamentSelection(pop) {
            const tournamentSize = 5;
            let best = null;
            for (let i = 0; i < tournamentSize; i++) {
                const randomIndividual = pop[Math.floor(Math.random() * pop.length)];
                if (best === null || randomIndividual.fitness > best.fitness) {
                    best = randomIndividual;
                }
            }
            return best;
        }

        function crossover(parent1, parent2) {
            const crossoverPoint = Math.floor(Math.random() * parent1.chromosome.length);
            const child1Chromosome = parent1.chromosome.slice(0, crossoverPoint).concat(parent2.chromosome.slice(crossoverPoint));
            const child2Chromosome = parent2.chromosome.slice(0, crossoverPoint).concat(parent1.chromosome.slice(crossoverPoint));
            return [
                { chromosome: child1Chromosome, fitness: 0 },
                { chromosome: child2Chromosome, fitness: 0 }
            ];
        }

        function mutate(individual) {
            const moves = ['N', 'E', 'S', 'W'];
            for (let i = 0; i < individual.chromosome.length; i++) {
                if (Math.random() < mutationRate) {
                    individual.chromosome[i] = moves[Math.floor(Math.random() * 4)];
                }
            }
        }
        
        let bestIndividualOfAllTime = null;

        for (let gen = 0; gen < numGenerations; gen++) {
            population.forEach(ind => calculateFitness(ind));
            population.sort((a, b) => b.fitness - a.fitness);
            
            let bestOfGen = population[0];
            if (bestIndividualOfAllTime === null || bestOfGen.fitness > bestIndividualOfAllTime.fitness) {
                bestIndividualOfAllTime = JSON.parse(JSON.stringify(bestOfGen));
            }

            fitnessHistory.push(bestIndividualOfAllTime.fitness);

            let newPopulation = [];
            
            const elitismCount = Math.floor(populationSize * 0.1);
            for(let i = 0; i < elitismCount; i++) {
                newPopulation.push(population[i]);
            }

            while (newPopulation.length < populationSize) {
                const parent1 = tournamentSelection(population);
                const parent2 = tournamentSelection(population);
                let [child1, child2] = crossover(parent1, parent2);
                mutate(child1);
                mutate(child2);
                newPopulation.push(child1);
                if (newPopulation.length < populationSize) {
                    newPopulation.push(child2);
                }
            }
            population = newPopulation;
            
            statusMessage.textContent = `Génération ${gen + 1} / ${numGenerations} - Meilleure Fitness: ${Math.round(bestIndividualOfAllTime.fitness)}`;

            if (gen % 5 === 0 || gen === numGenerations - 1) {
                drawMaze();
                const bestPath = calculateFitness(bestIndividualOfAllTime);
                drawPath(bestPath);
                await new Promise(resolve => setTimeout(resolve, 20));
            }
        }

        drawMaze();
        const finalPath = calculateFitness(bestIndividualOfAllTime);
        drawPath(finalPath, '#A84C4C');
        
        let solutionFound = false;
        const lastPoint = finalPath[finalPath.length - 1];
        if (lastPoint.x === end.x && lastPoint.y === end.y) {
            solutionFound = true;
        }

        statusMessage.textContent = solutionFound ? `Solution trouvée en ${numGenerations} générations !` : `Optimisation terminée. La meilleure solution trouvée est affichée.`;

        updateChart(fitnessHistory);
        resultsSection.classList.remove('hidden');

        isSolving = false;
        solveBtn.disabled = false;
        generateBtn.disabled = false;
        solveBtn.textContent = "Résoudre";
        solveBtn.classList.replace('btn-secondary', 'btn-primary');
    });

    function updateChart(data) {
        const labels = Array.from({ length: data.length }, (_, i) => i + 1);
        if (fitnessChart) {
            fitnessChart.destroy();
        }
        const chartCtx = document.getElementById('fitnessChart').getContext('2d');
        fitnessChart = new Chart(chartCtx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Meilleure Fitness par Génération',
                    data: data,
                    borderColor: '#A88B79',
                    backgroundColor: 'rgba(168, 139, 121, 0.1)',
                    borderWidth: 2,
                    tension: 0.1,
                    fill: true,
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    y: {
                        beginAtZero: false,
                        title: {
                            display: true,
                            text: 'Fitness Score'
                        }
                    },
                    x: {
                         title: {
                            display: true,
                            text: 'Génération'
                        }
                    }
                },
                plugins: {
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                    },
                    legend: {
                        display: false
                    }
                }
            }
        });
    }

    const accordions = document.querySelectorAll('.accordion-button');
    accordions.forEach(button => {
        button.addEventListener('click', () => {
            const isOpening = !button.classList.contains('open');
            accordions.forEach(b => {
                b.classList.remove('open');
                b.querySelector('span:last-child').style.transform = 'rotate(0deg)';
            });
            if(isOpening) {
                button.classList.add('open');
                button.querySelector('span:last-child').style.transform = 'rotate(180deg)';
            }
        });
    });

    window.addEventListener('resize', drawMaze);
    initNewMaze(); // Initial maze generation on load
});
</script>
</body>
</html>
